# ============================================================================
# FILE: config.example.yaml
# Copy this to config.yaml and fill in your actual values
# config.yaml is gitignored and will never be committed
# ============================================================================

# ============================================================================
# SERVER CONFIGURATION
# ============================================================================
server:
  hostname: YOUR_SERVER_IP_OR_DOMAIN
  ssh_user: root
  ssh_key_path: ~/.ssh/id_rsa

# ============================================================================
# DEPLOYMENT USER
# ============================================================================
deployment:
  user: deployer
  user_home: /home/deployer

# ============================================================================
# GITHUB CONFIGURATION
# ============================================================================
github:
  organization: your-github-org
  ssh_deploy_key: |
    -----BEGIN OPENSSH PRIVATE KEY-----
    PASTE_YOUR_GITHUB_DEPLOY_KEY_HERE
    -----END OPENSSH PRIVATE KEY-----

# ============================================================================
# DOMAIN CONFIGURATION
# ============================================================================
domain:
  base_domain: example.com
  certbot_email: admin@example.com

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================
database:
  postgresql:
    version: 17
    admin_user: postgres
    admin_password: CHANGE_TO_STRONG_PASSWORD_HERE
    port: 5432
  
  redis:
    password: CHANGE_TO_STRONG_REDIS_PASSWORD_HERE
    port: 6379

# ============================================================================
# BACKUP CONFIGURATION
# ============================================================================
backup:
  directory: /var/backups/automated
  encryption_key: CHANGE_TO_STRONG_ENCRYPTION_KEY_32_CHARS_MIN
  retention_days: 30

# ============================================================================
# SERVICES CONFIGURATION
# Each service has its own config.yaml in the repo
# We only need: name, type, repo, ports, and database info
# ============================================================================
services:
  - name: auth-service
    type: go
    github_repo: auth-service
    backend_port: 8001
    frontend_enabled: true
    frontend_port: 3001
    database_enabled: true
    database_name: auth_db
    run_migrations: true
    
  - name: user-service
    type: go
    github_repo: user-service
    backend_port: 8002
    frontend_enabled: true
    frontend_port: 3002
    database_enabled: true
    database_name: user_db
    run_migrations: true
    
  - name: payment-service
    type: node
    github_repo: payment-service
    backend_port: 8003
    frontend_enabled: false
    database_enabled: true
    database_name: payment_db
    run_migrations: true
    
  - name: notification-service
    type: node
    github_repo: notification-service
    backend_port: 8004
    frontend_enabled: false
    database_enabled: true
    database_name: notification_db
    run_migrations: true

  - name: analytics-service
    type: go
    github_repo: analytics-service
    backend_port: 8005
    frontend_enabled: true
    frontend_port: 3003
    database_enabled: true
    database_name: analytics_db
    run_migrations: true

  - name: order-service
    type: go
    github_repo: order-service
    backend_port: 8006
    frontend_enabled: false
    database_enabled: true
    database_name: order_db
    run_migrations: true

  - name: inventory-service
    type: node
    github_repo: inventory-service
    backend_port: 8007
    frontend_enabled: true
    frontend_port: 3004
    database_enabled: true
    database_name: inventory_db
    run_migrations: true

  - name: catalog-service
    type: go
    github_repo: catalog-service
    backend_port: 8008
    frontend_enabled: true
    frontend_port: 3005
    database_enabled: true
    database_name: catalog_db
    run_migrations: true

  - name: review-service
    type: node
    github_repo: review-service
    backend_port: 8009
    frontend_enabled: false
    database_enabled: true
    database_name: review_db
    run_migrations: true

  - name: search-service
    type: go
    github_repo: search-service
    backend_port: 8010
    frontend_enabled: false
    database_enabled: true
    database_name: search_db
    run_migrations: true

  - name: recommendation-service
    type: go
    github_repo: recommendation-service
    backend_port: 8011
    frontend_enabled: false
    database_enabled: true
    database_name: recommendation_db
    run_migrations: true

  - name: shipping-service
    type: node
    github_repo: shipping-service
    backend_port: 8012
    frontend_enabled: false
    database_enabled: true
    database_name: shipping_db
    run_migrations: true

  - name: customer-service
    type: go
    github_repo: customer-service
    backend_port: 8013
    frontend_enabled: true
    frontend_port: 3006
    database_enabled: true
    database_name: customer_db
    run_migrations: true

  - name: reporting-service
    type: node
    github_repo: reporting-service
    backend_port: 8014
    frontend_enabled: true
    frontend_port: 3007
    database_enabled: true
    database_name: reporting_db
    run_migrations: true

  - name: webhook-service
    type: go
    github_repo: webhook-service
    backend_port: 8015
    frontend_enabled: false
    database_enabled: true
    database_name: webhook_db
    run_migrations: true

  - name: email-service
    type: go
    github_repo: email-service
    backend_port: 8016
    frontend_enabled: false
    database_enabled: false
    run_migrations: false

  - name: sms-service
    type: node
    github_repo: sms-service
    backend_port: 8017
    frontend_enabled: false
    database_enabled: true
    database_name: sms_db
    run_migrations: true

  - name: file-storage-service
    type: go
    github_repo: file-storage-service
    backend_port: 8018
    frontend_enabled: false
    database_enabled: true
    database_name: file_storage_db
    run_migrations: true

  - name: audit-service
    type: node
    github_repo: audit-service
    backend_port: 8019
    frontend_enabled: false
    database_enabled: true
    database_name: audit_db
    run_migrations: true

  - name: metrics-service
    type: go
    github_repo: metrics-service
    backend_port: 8020
    frontend_enabled: true
    frontend_port: 3008
    database_enabled: true
    database_name: metrics_db
    run_migrations: true

  - name: billing-service
    type: node
    github_repo: billing-service
    backend_port: 8021
    frontend_enabled: false
    database_enabled: true
    database_name: billing_db
    run_migrations: true

  - name: subscription-service
    type: go
    github_repo: subscription-service
    backend_port: 8022
    frontend_enabled: false
    database_enabled: true
    database_name: subscription_db
    run_migrations: true

  - name: chat-service
    type: node
    github_repo: chat-service
    backend_port: 8023
    frontend_enabled: true
    frontend_port: 3009
    database_enabled: true
    database_name: chat_db
    run_migrations: true

  - name: media-service
    type: go
    github_repo: media-service
    backend_port: 8024
    frontend_enabled: false
    database_enabled: true
    database_name: media_db
    run_migrations: true

  - name: location-service
    type: node
    github_repo: location-service
    backend_port: 8025
    frontend_enabled: false
    database_enabled: true
    database_name: location_db
    run_migrations: true

---
# ============================================================================
# FILE: inventory.ini
# Server inventory - can be committed (no secrets)
# ============================================================================
[production]
prod-server ansible_connection=local

[production:vars]
ansible_python_interpreter=/usr/bin/python3

---
# ============================================================================
# FILE: ansible.cfg
# Ansible configuration
# ============================================================================
[defaults]
inventory = inventory.ini
host_key_checking = False
retry_files_enabled = False
deprecation_warnings = False

[ssh_connection]
pipelining = True
control_path = /tmp/ansible-ssh-%%h-%%p-%%r

---
# ============================================================================
# FILE: playbooks/provision.yml
# Provision Ubuntu Server with all dependencies
# ============================================================================
- name: Provision Ubuntu Server for Multi-Service Deployment
  hosts: production
  become: yes
  vars_files:
    - ../config.yaml
  vars:
    deploy_user: "{{ deployment.user }}"
    deploy_user_home: "{{ deployment.user_home }}"
    github_ssh_key: "{{ github.ssh_deploy_key }}"
    postgres_version: "{{ database.postgresql.version }}"
    postgres_password: "{{ database.postgresql.admin_password }}"
    redis_password: "{{ database.redis.password }}"
    certbot_email: "{{ domain.certbot_email }}"
    backup_dir: "{{ backup.directory }}"
  
  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Upgrade all packages
      apt:
        upgrade: dist
        autoremove: yes
        autoclean: yes

    - name: Install essential packages
      apt:
        name:
          - git
          - curl
          - wget
          - build-essential
          - software-properties-common
          - ufw
          - certbot
          - python3-certbot-nginx
          - gnupg
          - lsb-release
          - ca-certificates
          - apt-transport-https
          - acl
        state: present

    - name: Add PostgreSQL repository key
      apt_key:
        url: https://www.postgresql.org/media/keys/ACCC4CF8.asc
        state: present

    - name: Add PostgreSQL repository
      apt_repository:
        repo: "deb http://apt.postgresql.org/pub/repos/apt {{ ansible_distribution_release }}-pgdg main"
        state: present

    - name: Install PostgreSQL
      apt:
        name:
          - "postgresql-{{ postgres_version }}"
          - "postgresql-contrib-{{ postgres_version }}"
          - postgresql-client
          - python3-psycopg2
        state: present
        update_cache: yes

    - name: Ensure PostgreSQL is running
      systemd:
        name: postgresql
        state: started
        enabled: yes

    - name: Set PostgreSQL password
      become_user: postgres
      postgresql_user:
        name: "{{ database.postgresql.admin_user }}"
        password: "{{ postgres_password }}"
        encrypted: yes

    - name: Configure PostgreSQL to accept password authentication
      lineinfile:
        path: "/etc/postgresql/{{ postgres_version }}/main/pg_hba.conf"
        regexp: '^local\s+all\s+postgres\s+peer'
        line: 'local   all             postgres                                md5'
        backup: yes
      notify: restart postgresql

    - name: Install Redis
      apt:
        name:
          - redis-server
          - python3-redis
        state: present

    - name: Configure Redis password
      lineinfile:
        path: /etc/redis/redis.conf
        regexp: '^# requirepass'
        line: "requirepass {{ redis_password }}"
        backup: yes
      notify: restart redis

    - name: Ensure Redis is running
      systemd:
        name: redis-server
        state: started
        enabled: yes

    - name: Download Go installer
      get_url:
        url: https://go.dev/dl/go1.22.0.linux-amd64.tar.gz
        dest: /tmp/go.tar.gz

    - name: Remove old Go installation
      file:
        path: /usr/local/go
        state: absent

    - name: Extract Go
      unarchive:
        src: /tmp/go.tar.gz
        dest: /usr/local
        remote_src: yes

    - name: Add Go to PATH
      lineinfile:
        path: /etc/profile.d/go.sh
        line: 'export PATH=$PATH:/usr/local/go/bin'
        create: yes
        mode: '0644'

    - name: Install Node.js repository
      shell: curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
      args:
        creates: /etc/apt/sources.list.d/nodesource.list

    - name: Install Node.js
      apt:
        name: nodejs
        state: present
        update_cache: yes

    - name: Install NGINX
      apt:
        name: nginx
        state: present

    - name: Ensure NGINX is running
      systemd:
        name: nginx
        state: started
        enabled: yes

    - name: Create deployment user
      user:
        name: "{{ deploy_user }}"
        shell: /bin/bash
        home: "{{ deploy_user_home }}"
        create_home: yes
        groups: sudo
        append: yes

    - name: Create .ssh directory
      file:
        path: "{{ deploy_user_home }}/.ssh"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0700'

    - name: Deploy GitHub SSH key
      copy:
        content: "{{ github_ssh_key }}"
        dest: "{{ deploy_user_home }}/.ssh/id_rsa"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0600'

    - name: Add GitHub to known_hosts
      known_hosts:
        name: github.com
        key: "{{ lookup('pipe', 'ssh-keyscan -t rsa github.com') }}"
        path: "{{ deploy_user_home }}/.ssh/known_hosts"
        state: present

    - name: Create apps directory
      file:
        path: "{{ deploy_user_home }}/apps"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0755'

    - name: Configure UFW defaults
      ufw:
        direction: "{{ item.direction }}"
        policy: "{{ item.policy }}"
      loop:
        - { direction: 'incoming', policy: 'deny' }
        - { direction: 'outgoing', policy: 'allow' }

    - name: Allow SSH
      ufw:
        rule: allow
        port: '22'
        proto: tcp

    - name: Allow HTTP
      ufw:
        rule: allow
        port: '80'
        proto: tcp

    - name: Allow HTTPS
      ufw:
        rule: allow
        port: '443'
        proto: tcp

    - name: Enable UFW
      ufw:
        state: enabled

    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0750'

  handlers:
    - name: restart postgresql
      systemd:
        name: postgresql
        state: restarted

    - name: restart redis
      systemd:
        name: redis-server
        state: restarted

---
# ============================================================================
# FILE: playbooks/deploy.yml
# Deploy all services from GitHub
# ============================================================================
- name: Deploy All Services
  hosts: production
  become: yes
  vars_files:
    - ../config.yaml
  vars:
    deploy_user: "{{ deployment.user }}"
    deploy_user_home: "{{ deployment.user_home }}"
    github_org: "{{ github.organization }}"
    go_bin_path: /usr/local/go/bin/go
  
  tasks:
    - name: Clone/Update service repositories
      become_user: "{{ deploy_user }}"
      git:
        repo: "git@github.com:{{ github_org }}/{{ item.github_repo }}.git"
        dest: "{{ deploy_user_home }}/apps/{{ item.name }}"
        version: main
        accept_hostkey: yes
        key_file: "{{ deploy_user_home }}/.ssh/id_rsa"
        force: yes
      loop: "{{ services }}"
      register: git_clone

    - name: Create database for each service
      become_user: postgres
      postgresql_db:
        name: "{{ item.database_name }}"
        state: present
      loop: "{{ services }}"
      when: item.database_enabled | default(false)
      ignore_errors: yes

    - name: Build Go services
      become_user: "{{ deploy_user }}"
      shell: |
        export PATH=$PATH:/usr/local/go/bin
        {{ go_bin_path }} build -o {{ item.name }} .
      args:
        chdir: "{{ deploy_user_home }}/apps/{{ item.name }}"
      loop: "{{ services }}"
      when: item.type == 'go'

    - name: Install Node.js dependencies
      become_user: "{{ deploy_user }}"
      npm:
        path: "{{ deploy_user_home }}/apps/{{ item.name }}"
        state: present
      loop: "{{ services }}"
      when: item.type == 'node'

    - name: Build Node.js services
      become_user: "{{ deploy_user }}"
      command: npm run build
      args:
        chdir: "{{ deploy_user_home }}/apps/{{ item.name }}"
      loop: "{{ services }}"
      when: item.type == 'node'
      ignore_errors: yes

    - name: Run database migrations
      become_user: "{{ deploy_user }}"
      shell: |
        if [ -f "migrations.sh" ]; then
          bash migrations.sh
        elif [ -f "migrate" ]; then
          ./migrate up
        elif [ -d "migrations" ] && [ "{{ item.type }}" = "go" ]; then
          export PATH=$PATH:/usr/local/go/bin
          {{ go_bin_path }} run migrations/*.go
        elif [ -d "migrations" ] && [ "{{ item.type }}" = "node" ]; then
          npm run migrate
        fi
      args:
        chdir: "{{ deploy_user_home }}/apps/{{ item.name }}"
      loop: "{{ services }}"
      when: 
        - item.database_enabled | default(false)
        - item.run_migrations | default(false)
      ignore_errors: yes

    - name: Create systemd service files for backends
      template:
        src: ../templates/systemd-service.j2
        dest: "/etc/systemd/system/{{ item.name }}.service"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ services }}"
      vars:
        service_item: "{{ item }}"
        is_frontend: false
      notify: reload systemd

    - name: Enable and start backend services
      systemd:
        name: "{{ item.name }}"
        enabled: yes
        state: restarted
        daemon_reload: yes
      loop: "{{ services }}"

    - name: Build frontend applications
      become_user: "{{ deploy_user }}"
      shell: |
        if [ -d "frontend" ]; then
          cd frontend
          npm install
          npm run build
        fi
      args:
        chdir: "{{ deploy_user_home }}/apps/{{ item.name }}"
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)
      ignore_errors: yes

    - name: Create systemd service for frontends
      template:
        src: ../templates/systemd-service.j2
        dest: "/etc/systemd/system/{{ item.name }}-frontend.service"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)
      vars:
        service_item: "{{ item }}"
        is_frontend: true
      notify: reload systemd

    - name: Enable and start frontend services
      systemd:
        name: "{{ item.name }}-frontend"
        enabled: yes
        state: restarted
        daemon_reload: yes
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes

---
# ============================================================================
# FILE: playbooks/nginx.yml
# Configure NGINX reverse proxy and SSL
# ============================================================================
- name: Configure NGINX for All Services
  hosts: production
  become: yes
  vars_files:
    - ../config.yaml
  vars:
    base_domain: "{{ domain.base_domain }}"
    certbot_email: "{{ domain.certbot_email }}"
    deploy_user: "{{ deployment.user }}"
    deploy_user_home: "{{ deployment.user_home }}"
  
  tasks:
    - name: Remove default NGINX site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent

    - name: Create NGINX config for backend services
      template:
        src: ../templates/nginx-site.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.name }}-api"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ services }}"
      vars:
        service_type: backend
        service_domain: "api.{{ item.name }}.{{ base_domain }}"
        service_port: "{{ item.backend_port }}"
        service_name: "{{ item.name }}"
      notify: reload nginx

    - name: Enable backend NGINX configs
      file:
        src: "/etc/nginx/sites-available/{{ item.name }}-api"
        dest: "/etc/nginx/sites-enabled/{{ item.name }}-api"
        state: link
      loop: "{{ services }}"

    - name: Create NGINX config for frontend services
      template:
        src: ../templates/nginx-site.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.name }}-app"
        owner: root
        group: root
        mode: '0644'
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)
      vars:
        service_type: frontend
        service_domain: "app.{{ item.name }}.{{ base_domain }}"
        service_port: "{{ item.frontend_port }}"
        service_name: "{{ item.name }}"
        backend_port: "{{ item.backend_port }}"
        frontend_dir: "{{ deploy_user_home }}/apps/{{ item.name }}/frontend"
      notify: reload nginx

    - name: Enable frontend NGINX configs
      file:
        src: "/etc/nginx/sites-available/{{ item.name }}-app"
        dest: "/etc/nginx/sites-enabled/{{ item.name }}-app"
        state: link
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)

    - name: Test NGINX configuration
      command: nginx -t
      register: nginx_test
      changed_when: false

    - name: Reload NGINX
      systemd:
        name: nginx
        state: reloaded
      when: nginx_test.rc == 0

    - name: Obtain SSL certificates for backend services
      command: >
        certbot --nginx -d api.{{ item.name }}.{{ base_domain }}
        --non-interactive --agree-tos -m {{ certbot_email }}
      loop: "{{ services }}"
      ignore_errors: yes

    - name: Obtain SSL certificates for frontend services
      command: >
        certbot --nginx -d app.{{ item.name }}.{{ base_domain }}
        --non-interactive --agree-tos -m {{ certbot_email }}
      loop: "{{ services }}"
      when: item.frontend_enabled | default(false)
      ignore_errors: yes

    - name: Setup certbot renewal cron
      cron:
        name: "Certbot renewal"
        minute: "0"
        hour: "3"
        job: "certbot renew --quiet --post-hook 'systemctl reload nginx'"

  handlers:
    - name: reload nginx
      systemd:
        name: nginx
        state: reloaded

---
# ============================================================================
# FILE: playbooks/backup.yml
# Backup databases and configurations
# ============================================================================
- name: Backup Databases and Configurations
  hosts: production
  become: yes
  vars_files:
    - ../config.yaml
  vars:
    timestamp: "{{ ansible_date_time.epoch }}"
    deploy_user: "{{ deployment.user }}"
    backup_dir: "{{ backup.directory }}"
    postgres_password: "{{ database.postgresql.admin_password }}"
    backup_encryption_key: "{{ backup.encryption_key }}"
    backup_retention_days: "{{ backup.retention_days }}"
  
  tasks:
    - name: Create backup directory for this run
      file:
        path: "{{ backup_dir }}/{{ timestamp }}"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"
        mode: '0750'

    - name: Backup all PostgreSQL databases
      become_user: postgres
      shell: |
        pg_dumpall > {{ backup_dir }}/{{ timestamp }}/postgresql_all.sql
      environment:
        PGPASSWORD: "{{ postgres_password }}"

    - name: Backup individual databases
      become_user: postgres
      postgresql_db:
        name: "{{ item.database_name }}"
        state: dump
        target: "{{ backup_dir }}/{{ timestamp }}/{{ item.name }}_db.sql"
      loop: "{{ services }}"
      when: item.database_enabled | default(false)
      ignore_errors: yes

    - name: Backup Redis data
      copy:
        src: /var/lib/redis/dump.rdb
        dest: "{{ backup_dir }}/{{ timestamp }}/redis_dump.rdb"
        remote_src: yes
      ignore_errors: yes

    - name: Backup NGINX configurations
      archive:
        path: /etc/nginx
        dest: "{{ backup_dir }}/{{ timestamp }}/nginx_config.tar.gz"

    - name: Backup service configurations
      archive:
        path: "{{ deployment.user_home }}/apps"
        dest: "{{ backup_dir }}/{{ timestamp }}/apps_config.tar.gz"
        exclude_path:
          - "{{ deployment.user_home }}/apps/*/node_modules"
          - "{{ deployment.user_home }}/apps/*/.git"

    - name: Encrypt backup directory
      shell: |
        tar czf - {{ timestamp }} | openssl enc -aes-256-cbc -salt -k "{{ backup_encryption_key }}" -out {{ timestamp }}.tar.gz.enc
      args:
        chdir: "{{ backup_dir }}"

    - name: Remove unencrypted backup
      file:
        path: "{{ backup_dir }}/{{ timestamp }}"
        state: absent

    - name: Remove old backups
      shell: |
        find {{ backup_dir }} -name "*.tar.gz.enc" -mtime +{{ backup_retention_days }} -delete

    - name: Display backup location
      debug:
        msg: "Backup created at {{ backup_dir }}/{{ timestamp }}.tar.gz.enc"

---
# ============================================================================
# FILE: playbooks/restore.yml
# Restore from backup
# ============================================================================
- name: Restore from Backup
  hosts: production
  become: yes
  vars_files:
    - ../config.yaml
  vars:
    deploy_user: "{{ deployment.user }}"
    backup_dir: "{{ backup.directory }}"
    postgres_password: "{{ database.postgresql.admin_password }}"
    backup_encryption_key: "{{ backup.encryption_key }}"
  vars_prompt:
    - name: backup_timestamp
      prompt: "Enter backup timestamp to restore (e.g., 1234567890)"
      private: no
  
  tasks:
    - name: Check if backup exists
      stat:
        path: "{{ backup_dir }}/{{ backup_timestamp }}.tar.gz.enc"
      register: backup_file

    - name: Fail if backup doesn't exist
      fail:
        msg: "Backup file not found: {{ backup_dir }}/{{ backup_timestamp }}.tar.gz.enc"
      when: not backup_file.stat.exists

    - name: Decrypt backup
      shell: |
        openssl enc -aes-256-cbc -d -salt -k "{{ backup_encryption_key }}" -in {{ backup_timestamp }}.tar.gz.enc | tar xzf -
      args:
        chdir: "{{ backup_dir }}"

    - name: Stop all services
      systemd:
        name: "{{ item.name }}"
        state: stopped
      loop: "{{ services }}"
      ignore_errors: yes

    - name: Restore PostgreSQL databases
      become_user: postgres
      shell: |
        psql -f {{ backup_dir }}/{{ backup_timestamp }}/postgresql_all.sql
      environment:
        PGPASSWORD: "{{ postgres_password }}"

    - name: Stop Redis
      systemd:
        name: redis-server
        state: stopped

    - name: Restore Redis data
      copy:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/redis_dump.rdb"
        dest: /var/lib/redis/dump.rdb
        remote_src: yes
        owner: redis
        group: redis

    - name: Start Redis
      systemd:
        name: redis-server
        state: started

    - name: Restore NGINX configuration
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/nginx_config.tar.gz"
        dest: /etc/
        remote_src: yes

    - name: Restore application configurations
      unarchive:
        src: "{{ backup_dir }}/{{ backup_timestamp }}/apps_config.tar.gz"
        dest: "{{ deployment.user_home }}/"
        remote_src: yes
        owner: "{{ deploy_user }}"
        group: "{{ deploy_user }}"

    - name: Reload NGINX
      systemd:
        name: nginx
        state: reloaded

    - name: Start all services
      systemd:
        name: "{{ item.name }}"
        state: started
      loop: "{{ services }}"

    - name: Clean up decrypted backup
      file:
        path: "{{ backup_dir }}/{{ backup_timestamp }}"
        state: absent

---
# ============================================================================
# FILE: templates/systemd-service.j2
# Systemd service template for both backend and frontend
# ============================================================================
[Unit]
Description={{ service_item.name }}{% if is_frontend | default(false) %} Frontend{% endif %} Service
After=network.target{% if service_item.database_enabled | default(false) %} postgresql.service redis-server.service{% endif %}

[Service]
Type=simple
User={{ deploy_user }}
{% if is_frontend | default(false) %}
WorkingDirectory={{ deploy_user_home }}/apps/{{ service_item.name }}/frontend
{% if service_item.type == 'node' %}
ExecStart=/usr/bin/node {{ deploy_user_home }}/apps/{{ service_item.name }}/frontend/dist/index.js
{% else %}
ExecStart=/usr/bin/node {{ deploy_user_home }}/apps/{{ service_item.name }}/frontend/dist/server.js
{% endif %}
{% else %}
WorkingDirectory={{ deploy_user_home }}/apps/{{ service_item.name }}
{% if service_item.type == 'go' %}
ExecStart={{ deploy_user_home }}/apps/{{ service_item.name }}/{{ service_item.name }}
{% elif service_item.type == 'node' %}
ExecStart=/usr/bin/node {{ deploy_user_home }}/apps/{{ service_item.name }}/dist/index.js
{% endif %}
{% endif %}
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier={{ service_item.name }}{% if is_frontend | default(false) %}-frontend{% endif %}

[Install]
WantedBy=multi-user.target

---
# ============================================================================
# FILE: templates/nginx-site.conf.j2
# NGINX reverse proxy configuration template
# ============================================================================
server {
    listen 80;
    server_name {{ service_domain }};

    {% if service_type == 'backend' %}
    location / {
        proxy_pass http://localhost:{{ service_port }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffer settings
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
        proxy_busy_buffers_size 8k;
    }
    {% else %}
    root {{ frontend_dir }}/dist;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://localhost:{{ backend_port }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # Static file caching
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    {% endif %}

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/x-javascript application/xml+rss 
               application/json application/javascript 
               image/svg+xml;

    # Rate limiting (uncomment if needed)
    # limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    # limit_req zone=api_limit burst=20 nodelay;

    # Logging
    access_log /var/log/nginx/{{ service_domain }}_access.log;
    error_log /var/log/nginx/{{ service_domain }}_error.log;
    
    # Max body size
    client_max_body_size 10M;
}

---
# ============================================================================
# FILE: .gitignore
# Protect sensitive files
# ============================================================================
# Configuration file with all secrets (NEVER COMMIT)
config.yaml
config.yml

# Ansible Vault password files
.vault_pass
.vault_password
vault_pass.txt
vault_password.txt
*vault_pass*
*vault_password*

# SSH keys
*.pem
*.key
*_rsa
*_rsa.pub
*_ed25519
*_ed25519.pub
id_rsa
id_rsa.pub
deploy_key
deploy_key.pub
*.ppk

# Environment files
.env
.env.*
.env.local
.env.production
.env.staging
*.env

# Certificate files
*.crt
*.csr
*.p12
*.pfx
*.cer

# Database dumps and backups
*.sql
*.dump
*.backup
dumps/
backups/
*.tar.gz.enc
*.tar.gz

# Ansible retry files
*.retry

# Ansible facts cache
facts.d/
.facts/
ansible_facts/

# Ansible cache
.ansible/
*.cache

# Python
__pycache__/
*.py[cod]
venv/
env/
.venv/

# IDEs
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Temporary files
tmp/
temp/
*.tmp

---
# ============================================================================
# FILE: README.md
# Complete documentation
# ============================================================================

# Automated Infrastructure Deployment with Ansible

Deploy 25+ Go/Node.js microservices on Ubuntu 22.04 LTS with PostgreSQL, Redis, NGINX, and automated SSL.

## üìÅ Project Structure

```
ignition/
‚îú‚îÄ‚îÄ config.yaml              # YOUR SECRETS (gitignored, never commit)
‚îú‚îÄ‚îÄ config.example.yaml      # Template (commit this)
‚îú‚îÄ‚îÄ inventory.ini            # Server inventory
‚îú‚îÄ‚îÄ ansible.cfg              # Ansible configuration
‚îú‚îÄ‚îÄ .gitignore              # Protects secrets
‚îú‚îÄ‚îÄ README.md               # This file
‚îú‚îÄ‚îÄ playbooks/
‚îÇ   ‚îú‚îÄ‚îÄ provision.yml       # Server provisioning
‚îÇ   ‚îú‚îÄ‚îÄ deploy.yml          # Service deployment
‚îÇ   ‚îú‚îÄ‚îÄ nginx.yml           # NGINX + SSL setup
‚îÇ   ‚îú‚îÄ‚îÄ backup.yml          # Automated backups
‚îÇ   ‚îî‚îÄ‚îÄ restore.yml         # Restore from backup
‚îî‚îÄ‚îÄ templates/
    ‚îú‚îÄ‚îÄ systemd-service.j2  # Systemd unit template
    ‚îî‚îÄ‚îÄ nginx-site.conf.j2  # NGINX config template
```

## üöÄ Quick Start

### 1. Install Ansible

```bash
# Ubuntu/Debian
sudo apt update && sudo apt install ansible

# macOS
brew install ansible

# Verify
ansible --version
```

### 2. Setup Configuration

```bash
# Copy template
cp config.example.yaml config.yaml

# Edit with your values
nano config.yaml
```

### 3. Configure Your Services

In `config.yaml`, each service needs:

```yaml
services:
  - name: auth-service           # Service identifier
    type: go                     # 'go' or 'node'
    github_repo: auth-service    # GitHub repo name
    backend_port: 8001           # Unique port
    frontend_enabled: true       # Has frontend?
    frontend_port: 3001          # Frontend port (if enabled)
    database_enabled: true       # Needs database?
    database_name: auth_db       # Database name
    run_migrations: true         # Run migrations?
```

**Important:** Each service reads its own `config.yaml` from its repository. This Ansible config only handles:
- ‚úÖ Which repos to clone
- ‚úÖ Port assignments
- ‚úÖ Database creation
- ‚úÖ Service orchestration

### 4. Setup GitHub Deploy Key

```bash
# Generate SSH key
ssh-keygen -t rsa -b 4096 -C "deploy@yourcompany.com" -f ~/.ssh/github_deploy_key

# Add public key to GitHub org
cat ~/.ssh/github_deploy_key.pub
# Go to: https://github.com/organizations/YOUR-ORG/settings/keys
# Add as deploy key with READ access only

# Add private key to config.yaml
cat ~/.ssh/github_deploy_key
# Paste entire output (including BEGIN/END lines) into config.yaml
```

### 5. Setup DNS

Create A records for each service:

```
api.auth-service.example.com     ‚Üí YOUR_SERVER_IP
app.auth-service.example.com     ‚Üí YOUR_SERVER_IP
api.user-service.example.com     ‚Üí YOUR_SERVER_IP
app.user-service.example.com     ‚Üí YOUR_SERVER_IP
# ... for all services
```

### 6. Deploy

```bash
# Step 1: Provision server (one time)
ansible-playbook -i inventory.ini playbooks/provision.yml -e @config.yaml

# Step 2: Deploy all services
ansible-playbook -i inventory.ini playbooks/deploy.yml -e @config.yaml

# Step 3: Setup NGINX + SSL
ansible-playbook -i inventory.ini playbooks/nginx.yml -e @config.yaml
```

## üìù Configuration Reference

### Server Connection

```yaml
server:
  hostname: 123.45.67.89        # Server IP or domain
  ssh_user: root                # SSH user
  ssh_key_path: ~/.ssh/id_rsa   # SSH private key path
```

### GitHub Settings

```yaml
github:
  organization: your-github-org  # GitHub organization name
  ssh_deploy_key: |              # Private deploy key
    -----BEGIN OPENSSH PRIVATE KEY-----
    ...
    -----END OPENSSH PRIVATE KEY-----
```

### Database Credentials

```yaml
database:
  postgresql:
    version: 17
    admin_user: postgres
    admin_password: "YourStrongPassword123!"  # Change this
    port: 5432
  
  redis:
    password: "AnotherStrongPassword456!"     # Change this
    port: 6379
```

### Service Configuration

Each service in the `services` array:

```yaml
- name: payment-service          # Unique service name
  type: node                     # 'go' or 'node'
  github_repo: payment-service   # Repo name (not full URL)
  backend_port: 8003             # Unique backend port (8001-8999)
  frontend_enabled: false        # true if has frontend
  frontend_port: 3003            # Frontend port (3001-3999) if enabled
  database_enabled: true         # true if needs PostgreSQL
  database_name: payment_db      # Database name
  run_migrations: true           # true to run migrations on deploy
```

**Service Config Files:** Each service repo should have its own `config.yaml` with:
- Database connection strings
- API keys
- Third-party credentials
- Service-specific settings

## üîß Operations

### Deploy Single Service

```bash
# Re-deploy one service after code changes
ansible-playbook -i inventory.ini playbooks/deploy.yml -e @config.yaml \
  --extra-vars "services=[{'name':'auth-service','type':'go','github_repo':'auth-service','backend_port':8001,'database_enabled':true,'database_name':'auth_db'}]"
```

### Check Service Status

```bash
# SSH into server
ssh deployer@YOUR_SERVER_IP

# Check service status
sudo systemctl status auth-service
sudo systemctl status auth-service-frontend

# View logs
sudo journalctl -u auth-service -f
sudo journalctl -u auth-service-frontend -f

# Restart service
sudo systemctl restart auth-service
```

### Manual Backup

```bash
ansible-playbook -i inventory.ini playbooks/backup.yml -e @config.yaml
```

### Restore from Backup

```bash
# List backups
ssh deployer@YOUR_SERVER_IP "ls -lh /var/backups/automated/"

# Restore (will prompt for timestamp)
ansible-playbook -i inventory.ini playbooks/restore.yml -e @config.yaml
```

## üóÑÔ∏è Database Management

```bash
# Connect to PostgreSQL
ssh deployer@YOUR_SERVER_IP
sudo -u postgres psql

# List databases
\l

# Connect to specific database
\c auth_db

# List tables
\dt

# Connect to Redis
redis-cli
AUTH your_redis_password
PING
KEYS *
```

## üåê Service URLs

After deployment, services are accessible at:

**Backend APIs:**
```
https://api.auth-service.example.com
https://api.user-service.example.com
https://api.payment-service.example.com
```

**Frontend Apps:**
```
https://app.auth-service.example.com
https://app.user-service.example.com
https://app.catalog-service.example.com
```

## üîê Security Features

- ‚úÖ UFW firewall (ports 22, 80, 443 only)
- ‚úÖ SSL/TLS certificates via Let's Encrypt
- ‚úÖ Auto-renewal of SSL certificates
- ‚úÖ GitHub deploy key (read-only)
- ‚úÖ PostgreSQL password authentication
- ‚úÖ Redis password protection
- ‚úÖ Encrypted backups (AES-256)
- ‚úÖ Service isolation (dedicated user)
- ‚úÖ Security headers in NGINX

## üõ†Ô∏è Troubleshooting

### Service Won't Start

```bash
# Check status
sudo systemctl status service-name

# Check logs
sudo journalctl -u service-name -n 50

# Check if port is in use
sudo lsof -i :8001

# Verify binary exists (Go services)
ls -la /home/deployer/apps/service-name/service-name

# Check service config file exists
ls -la /home/deployer/apps/service-name/config.yaml
```

### Database Connection Issues

```bash
# Check PostgreSQL is running
sudo systemctl status postgresql

# Verify database exists
sudo -u postgres psql -l | grep service_db

# Test connection
sudo -u postgres psql -d service_db -c "SELECT 1;"
```

### SSL Certificate Issues

```bash
# Check certificates
sudo certbot certificates

# Renew manually
sudo certbot renew --dry-run

# Check NGINX config
sudo nginx -t
```

### DNS Not Resolving

```bash
# Check DNS
nslookup api.auth-service.example.com
dig api.auth-service.example.com

# Wait for DNS propagation (can take 5-30 minutes)
```

## üìä Service Configuration in Repos

Each service repository should have its own `config.yaml`:

```yaml
# Example: auth-service/config.yaml
server:
  port: 8001
  host: 0.0.0.0

database:
  host: localhost
  port: 5432
  name: auth_db
  user: postgres
  password: ${DB_PASSWORD}  # From environment or config

redis:
  host: localhost
  port: 6379
  password: ${REDIS_PASSWORD}

jwt:
  secret: ${JWT_SECRET}
  expiry: 24h

logging:
  level: info
  format: json
```

This separation allows:
- ‚úÖ Service-specific configuration in each repo
- ‚úÖ Infrastructure-level config in Ansible
- ‚úÖ Easy local development
- ‚úÖ Clear separation of concerns

## üîÑ Adding New Services

1. Add to `config.yaml`:

```yaml
services:
  - name: new-service
    type: go
    github_repo: new-service
    backend_port: 8026           # Use next available port
    frontend_enabled: false
    database_enabled: true
    database_name: new_service_db
    run_migrations: true
```

2. Create DNS records:
```
api.new-service.example.com ‚Üí YOUR_SERVER_IP
```

3. Deploy:
```bash
ansible-playbook -i inventory.ini playbooks/deploy.yml -e @config.yaml
ansible-playbook -i inventory.ini playbooks/nginx.yml -e @config.yaml
```

## üìà Monitoring

Service logs are available via `journalctl`:

```bash
# Real-time logs
sudo journalctl -u auth-service -f

# Last 100 lines
sudo journalctl -u auth-service -n 100

# Logs since specific time
sudo journalctl -u auth-service --since "1 hour ago"

# All service logs
sudo journalctl -f | grep -E '(auth|user|payment)-service'
```

NGINX logs:

```bash
# Access logs
sudo tail -f /var/log/nginx/api.auth-service.example.com_access.log

# Error logs
sudo tail -f /var/log/nginx/api.auth-service.example.com_error.log
```

## üîí Security Checklist

- [ ] config.yaml is gitignored
- [ ] Strong database passwords (20+ chars)
- [ ] GitHub deploy key is read-only
- [ ] SSH key has passphrase
- [ ] UFW firewall enabled
- [ ] SSL certificates active
- [ ] Backups are encrypted
- [ ] Services run as non-root user
- [ ] Each service has its own config.yaml with secrets

## üìö Additional Resources

- [Ansible Documentation](https://docs.ansible.com/)
- [PostgreSQL Docs](https://www.postgresql.org/docs/)
- [NGINX Configuration](https://nginx.org/en/docs/)
- [Let's Encrypt](https://letsencrypt.org/)
- [systemd Service Management](https://www.freedesktop.org/software/systemd/man/systemd.service.html)

## ü§ù Support

For issues:
1. Check service logs: `sudo journalctl -u service-name -f`
2. Verify configuration: `cat /home/deployer/apps/service-name/config.yaml`
3. Test connectivity: `curl http://localhost:8001/health`
4. Check NGINX: `sudo nginx -t`

---

**‚ö†Ô∏è Remember:** 
- Never commit `config.yaml` to Git
- Keep backup encryption keys safe
- Rotate database passwords regularly
- Monitor service logs for issues